##### MySQL常见瓶颈

CPU: CPU在饱和的时候一般发生在数据装入内存或从磁盘上读取数据的时候

IO: 磁盘I/O瓶颈发生在装入数据远大于内存容量的时候

服务器硬件的性能瓶颈: top, free iostat和vmstat来查看系统的性能状态



#### Explain

Explain是一种执行计划, 模拟优化器执行SQL查询语句

##### 作用

表的读取顺序 - 数据读取操作的操作类型 - 哪些索引可以使用

哪些索引被实际使用 - 表之间的引用 - 每张表有多少行被优化器查询

##### 使用

Explain + SQL语句

##### 所包含的信息

| id   | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra |
| ---- | ----------- | ----- | ---- | ------------- | ---- | ------- | ---- | ---- | ----- |



#### 各自段解释

##### id

select 查询的序列号, 包含一组数字, 表示查询中执行select子句或操作表的顺序

###### 三种情况

- id相同, 执行顺序由上至下
- id不同, id值越大越先执行 (如果是子查询, 最里优先度最高, 即id越高)
- id相同和不同的情况同时存在(则按照上面两个规则)

##### select_type

| SIMPLE                                       | PRIMARY                                                  | SUBQUERY                          | DERIUED                                                      | UNION                                                        | UNION RESULT              |
| -------------------------------------------- | -------------------------------------------------------- | --------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------- |
| 简单的select查询,查询中不包含子查询或者UNION | 查询中若包含任何复制的子部分, 最外层查询则被标记为该类型 | 在SELECT或WHERE列表中包含了子查询 | 在FROM列表中包含的子查询被标记为DERIVED(衍生), MySQL会递归执行这些子查询, 吧结构放到临时表中 | 若第二个SELECT出现在UNION之后,则被标记为UNION; 若UNION包含在FROM子句的子查询中, 外层SELECT将被标记为DERIUED | 从UNION表获取结果的SELECT |

##### type

| ALL[遍历] | index | range | ref  | eq_ref | const, system | NULL |
| --------- | ----- | ----- | ---- | ------ | ------------- | ---- |

访问类型排列

显示查询使用了何种类型: 从最好到最差依次是: system > const > eq_ref > ref > range > index > ALL

优化到 ref - range的级别即可

const常出现于主键索引, 常量查询

ref - 非唯一性索引扫描, 返回匹配某个单独值的所有行, 本质上也是一种索引访问, 它返回所有匹配某个单独值的行, 然而, 它可能会找到多个符合条件的行, 所有他应该属于查找和扫描的混合

range - 范围查询, 只检索给定范围的行, 使用一个索引来选择行, key列显示使用了哪个索引, 一般就是在你的where语句中出现了between, <, >, in等的查询, 这种范围索引扫描比全表扫描要好, 因为它只需要开始于索引的某点而结束于另一点

index - Full index Scan, 遍历索引树

##### possible_keys - 可能被用到的索引

显示可能应用在这张表中的索引, 一个或多个, 查询涉及到的字段上若存在索引, 则该索引将被列出, 但不一定被查询实际使用

##### key - 实际用到的索引

如果没用, 那么NULL

查询中如果使用覆盖索引(字段与索引一一对应, 全部吻合), 那么此时就无possible_keys(无需全表扫描), 直接从索引中获取key即可

##### key_len

表示索引中使用的字节数, 可通过该列计算查询中使用的索引的长度. 在不损失精确性的情况下, 长度越短越好

key_len表示的值为索引字段的最大可能长度, 并非实际使用长度, 即key_len是根据表定义计算而得, 不少通过表内检索得出的

##### ref

显示索引的哪一列被使用了, 如果可能的话, 是一个常数. 那些列或常量被用于查找索引列上的值

##### rows

每张表有多少行被优化器查询

##### Extra

不适合在里面显示, 但非常重要的事情

如filesort 文件内排序(多了内部排序)

temporary 临时表 [常见于order by 和 group by]

index [如果同时出现using where, 表明索引被用来执行索引键值的查找; 如果没有则表明索引用来读取数据而非执行查找动作]

where 使用了where过滤

join buffer 使用了连接缓存

impossible where [where子句的值总是false, 不能用来获取任何元组]

select tables optimized away

distinct