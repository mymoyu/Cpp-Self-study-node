#### 索引是什么?

索引(Index)是帮助MySQL高效获取数据的数据结构【排好序的快速查找数据结构】。

##### 详细的解释

索引是定义在存储表基础之上，有助于无需检查所有记录而快速定位所需记录的一种辅助存储结构，由一系列存储在磁盘上的索引项（index entries）组成，每个索引项由两部分(索引字段和行指针)组成。

索引字段：由table中某些列(通常是一列)中的值串接而成。索引中通常存储了索引字段的每一个值(也有不是这样的情况)。索引字段类似于词典中的词条

行指针：指向Table中包含索引字段值的记录在磁盘中的存储位置。行指针类似于词条在书籍，词典中出现的页码。

##### 索引文件组织方式有两种

排序索引文件(Ordered indices): 按索引字段值的某一种顺序组织存储

散列索引文件(Hash indices):		按索引字段值使用散列函数分配散列桶的方式存储



##### 索引性能判断条件

访问时间 | 插入时间 | 删除时间 | 空间负载 | 支持存取的有效性



##### 三种key

排序码(Order Key) --- 对主文件进行排序存储的那些属性或属性组

索引码(Index Key) --- 即索引字段, 不一定具有唯一性

搜索码(Search Key) --- 在主文件中查找记录的属性或属性集



##### 稠密索引和稀疏索引

对于主文件中每一个记录都有一个索引项与之对应, 指明记录所在的位置, 这样的索引称稠密索引(dense index)

部分记录有索引项与之对应, 这样的索引称为非稠密索引(undense index) 或 稀疏索引(sparse index)

###### 稀疏索引定位记录

找到相邻小于其的最大索引字段值所对应的索引项, 然后进行扫描

对比稠密索引: 空间占用更小, 维护任务更轻, 但速度更慢

平衡方案: 每一个存储块(磁盘块)一个索引项 --- 主索引

###### 稠密索引

先查索引, 然后根据索引读取主文件

当索引字段并非排序且索引字段不少候选键, 此时就需要重复的索引项

但为了检索方便, 可以建立一个具有唯一值的索引表, 每个索引项指向一个指针桶(数组或者链表), 里面存储相同索引字段的多个指针, [此处的指针桶作为中间层]



##### 主索引与辅助索引

主索引(通常是稀疏索引, 唯一)通常是对每一存储块有一个索引项, 索引项的总数和存储表所占的存储块数目相同, 存储表的每一个存储块的第一条记录又称为锚记录(anchor record), 或简称块锚(block anchor)

通常建立在有序主文件, 基于主码排序字段上

辅助索引(稠密索引, 可多个)是定义在主文件的任一或多个非排序字段上的辅助存储结构

通常是对某一非排序字段的每一个不同值有一个索引项: 索引字段即是该字段的不同值, 而指针则指向包括该记录的块或该记录本身;

当非排序字段为索引字段时, 如该字段值不唯一, 则要采用一个类似于链表的结构来保存该字段值的所有记录的位置.

可以利用主索引重新组织主文件数据, 但辅助索引不能改变主文件数据



##### 聚簇索引和非聚簇索引

聚簇索引 -- 是指索引中邻近的记录在主文件中也是邻近存储的;

非聚簇索引 -- 是指索引中邻近的记录在主文件中不一定是邻近存储的.

一个主文件中只能由一个聚簇索引文件, 但可以有多个非聚簇索引文件

主索引/聚簇索引是能够觉得记录存储位置的索引, 而非聚簇索引只能用于查询;



##### 倒排索引[常用于查询文档]

正排: 一个文档包含了哪些词汇?

倒排: 一个词汇包含在哪些文档?

类似于一个索引表并且引入一个中间结构(指针桶)

多级索引: 当索引项较多时, 可以针对索引再建立索引, 依此形成多级索引

常用的多级索引形式: B树/B+树索引

多属性索引: 索引字段有Table的多个属性值组合在一起形成的索引

散列索引: 使用散列技术组织索引

网格索引: 使用多个索引字段进行交叉联合定位和检索



##### 在索引上的查找（B+树）

为了加快查找，可以维护一个二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在一定的复杂度内获取到相应的数据，从而快速的检索处符合条件的记录。

当数据被删除时会做一个伪删除，做一个逻辑删除【也就是表面删除实际没删】

###### 注意：要同时更新索引文件和主文件



索引本身也很大的关系，不可能全部存储在内存中，因为索引往往以索引文件的形式存储在磁盘上

索引的类型：聚集索引，次要索引，覆盖索引，前缀索引，复合索引，唯一索引

唯一索引默认使用B+树索引，除此还有哈希索引



B+树的每一个结点皆为一个存储块

B+树的特点: 能够自动保持与主文件大小相适应的树的层次, 每个索引块的指针利用率都在50%-100%之间

一个存储块存放n-1个索引项和n个指针

计算索引项数目, 首先要知道存储块大小dataSize = 4096 Byte, 整数型索引字段值wordSize = 4 Byte

指针pointer = 8 Byte

则: n应该满足 4(n-1) + 8n <= 4096 ; n取最大值 ; n = 341

下图是叶节点和非叶结点的模型

![image-20220223151010744](.\img\B+树的结点模型.png)

一个索引块实际使用的索引指针个数d, 需满足(n/2 <= d <= n)

根结点则需要至少2个指针被使用即可

下图是B+ (注意B是balance)树的实际模型

![image-20220223151756183](.\img\B+树的整体模型.png)

##### 索引的优势

提高数据检索的效率，降低数据库的IO成本

通过索引列对数据排序，降低数据排序的成本，降低了CPU的消耗

##### 索引的劣势

索引是需要占用空间的，提高了查询速度，却降低更新表的速度【insert，update， delete】

原因：更新表时不仅要保存数据，还要保存一下索引文件的每次更新添加了索引列的字段，都会调整因为更新所代理的键值变化后的索引信息

索引只是提高效率的一个因素，如果你有大数据量的表就需要考虑如何建立优秀的索引或优化查询



索引最好不要超过5个

单值索引：即一个索引只包含单个列表，一个表可以有多个单列索引

唯一索引：索引列的值必须唯一，但允许有空值

复合索引：即一个索引包含多个列



##### 基本语法

创建：CREATE [UNIQUE] INDEX indexName ON mytable(columnname(length));

​			ALTER mytable ADD [UNIQUE] INDEX [indexName] ON (columnnname(length));

删除：DROP INDEX [indexName] ON mytable;

查看：SHOW INDEX FROM table_name;

PRIMARY KEY(主键索引，必须唯一)       				UNIQUE index_name(唯一索引)     

INDEX index_name(普通索引，可出现多次)     	FULLTEXT index_name(全文索引)



#### B树

![image-20220223172305550](.\img\B树的整体模型.png)



B树和B+树的合并与分裂操作是有差别的, 但原理相同